/**
 * extract-icons.ts
 *
 * This script extracts SVG icon definitions from @ng-icons npm packages and generates
 * C# wrapper classes for use in Blazor applications.
 *
 * Process Overview:
 * 1. Read version from @ng-icons/core package and update Directory.Build.props
 * 2. For each configured icon library:
 *    a. Load the npm package and discover available exports (icon variants/suffixes)
 *    b. Extract icon name/SVG pairs from each export
 *    c. Write individual SVG files and index files (for lazy loading)
 *    d. Generate a C# IconSet class with typed properties for each icon
 * 3. Update the demo app's page title with the total icon count
 *
 * Output Structure (per library):
 * - Icons/{suffix}/*.svg (individual SVG files per icon)
 * - Icons/{suffix}.index.json (icon name index for lazy loading)
 * - Icons.g.cs (generated C# class with lazy loading)
 *
 * Memory Optimization:
 * Icons are loaded individually on first access, not all at once.
 * This significantly reduces memory usage when only a few icons are used.
 */

import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

// =============================================================================
// Type Definitions
// =============================================================================

/** Mapping between npm package name and C# project name */
interface Library {
  npm: string;     // e.g., '@ng-icons/heroicons'
  project: string; // e.g., 'NgIcons.Heroicons'
}

// =============================================================================
// Configuration: Library Mappings
// =============================================================================

const libraries: Library[] = [
  { npm: '@ng-icons/akar-icons', project: 'NgIcons.AkarIcons' },
  { npm: '@ng-icons/bootstrap-icons', project: 'NgIcons.BootstrapIcons' },
  { npm: '@ng-icons/boxicons', project: 'NgIcons.Boxicons' },
  { npm: '@ng-icons/circum-icons', project: 'NgIcons.CircumIcons' },
  // Note: @ng-icons/core is excluded - it's the Angular infrastructure package, not an icon library
  { npm: '@ng-icons/cryptocurrency-icons', project: 'NgIcons.CryptocurrencyIcons' },
  { npm: '@ng-icons/css.gg', project: 'NgIcons.CssGg' },
  { npm: '@ng-icons/devicon', project: 'NgIcons.Devicon' },
  { npm: '@ng-icons/dripicons', project: 'NgIcons.Dripicons' },
  { npm: '@ng-icons/feather-icons', project: 'NgIcons.FeatherIcons' },
  { npm: '@ng-icons/flag-icons', project: 'NgIcons.FlagIcons' },
  { npm: '@ng-icons/font-awesome', project: 'NgIcons.FontAwesome' },
  { npm: '@ng-icons/game-icons', project: 'NgIcons.GameIcons' },
  { npm: '@ng-icons/heroicons', project: 'NgIcons.Heroicons' },
  { npm: '@ng-icons/huge-icons', project: 'NgIcons.HugeIcons' },
  { npm: '@ng-icons/iconoir', project: 'NgIcons.Iconoir' },
  { npm: '@ng-icons/iconsax', project: 'NgIcons.Iconsax' },
  { npm: '@ng-icons/ionicons', project: 'NgIcons.Ionicons' },
  { npm: '@ng-icons/jam-icons', project: 'NgIcons.JamIcons' },
  { npm: '@ng-icons/lets-icons', project: 'NgIcons.LetsIcons' },
  { npm: '@ng-icons/lucide', project: 'NgIcons.Lucide' },
  { npm: '@ng-icons/material-file-icons', project: 'NgIcons.MaterialFileIcons' },
  { npm: '@ng-icons/material-icons', project: 'NgIcons.MaterialIcons' },
  { npm: '@ng-icons/material-symbols', project: 'NgIcons.MaterialSymbols' },
  { npm: '@ng-icons/mynaui', project: 'NgIcons.Mynaui' },
  { npm: '@ng-icons/octicons', project: 'NgIcons.Octicons' },
  { npm: '@ng-icons/phosphor-icons', project: 'NgIcons.PhosphorIcons' },
  { npm: '@ng-icons/radix-icons', project: 'NgIcons.RadixIcons' },
  { npm: '@ng-icons/remixicon', project: 'NgIcons.Remixicon' },
  // Note: @ng-icons/schematics is excluded - it's Angular CLI schematics, not an icon library
  { npm: '@ng-icons/simple-icons', project: 'NgIcons.SimpleIcons' },
  { npm: '@ng-icons/solar-icons', project: 'NgIcons.SolarIcons' },
  { npm: '@ng-icons/svgl', project: 'NgIcons.Svgl' },
  { npm: '@ng-icons/tabler-icons', project: 'NgIcons.TablerIcons' },
  { npm: '@ng-icons/tdesign-icons', project: 'NgIcons.TdesignIcons' },
  { npm: '@ng-icons/typicons', project: 'NgIcons.Typicons' },
  { npm: '@ng-icons/ux-aspects', project: 'NgIcons.UxAspects' }
];

// =============================================================================
// C# Code Generation Templates
// =============================================================================

/**
 * Header template for generated C# files.
 * Uses base classes from NgIcons.Core for lazy loading logic.
 */
const header = `// <auto-generated>
// This file was generated by scripts/extract-icons.ts. Do not edit manually.
// </auto-generated>
#nullable enable
using NgIcons.Core;
`;

// =============================================================================
// Path Resolution
// =============================================================================

/** Directory containing this script */
const root = path.dirname(fileURLToPath(import.meta.url));

/** Repository root directory (parent of scripts/) */
const repoRoot = path.resolve(root, '..');

// =============================================================================
// Icon Loading Functions
// =============================================================================

/**
 * Dynamically imports an icon package and extracts all icon definitions.
 *
 * @ng-icons packages export icons as named string constants:
 *   export const heroArrowLeft = '<svg>...</svg>';
 *
 * This function filters for string exports (the SVG content) and returns
 * them as [name, svgContent] pairs.
 *
 * @param importPath - The npm package path to import (e.g., '@ng-icons/heroicons/outline')
 * @returns Array of [iconName, svgContent] tuples
 */
async function loadIcons(importPath: string): Promise<Array<[string, string]>> {
  const mod = await import(importPath);
  return Object.entries(mod).filter(([, value]) => typeof value === 'string') as Array<[string, string]>;
}

/** Represents a group of icons sharing the same variant/suffix */
interface SuffixIcons {
  suffix: string; // '' for default, 'baseline', 'outline', etc.
  icons: Array<[string, string]>; // [iconName, svgContent]
}

// =============================================================================
// C# Code Generation
// =============================================================================

/**
 * Generates the C# IconSet class for a library with lazy loading.
 *
 * The generated code uses concrete classes from NgIcons.Core:
 * - IconSet for simple libraries (no suffixes)
 * - IconSetWithSuffixes for libraries with variants (outline, solid, etc.)
 *
 * The generated code only contains:
 * - Static Instance field wrapping the concrete class
 * - Static properties for each icon (e.g., `Icons.heroArrowLeft`)
 *
 * All lazy loading logic and methods (Get, TryGet, PreloadAll, etc.) are
 * available through the Instance field.
 *
 * @param namespace - C# namespace (e.g., 'NgIcons.Heroicons')
 * @param suffixes - Available icon variants (empty string for default, 'outline', 'solid', etc.)
 * @param iconsBySuffix - Map of suffix to icon names for that suffix
 * @returns Complete C# file content
 */
function generateIconSetClass(namespace: string, suffixes: string[], iconsBySuffix: Map<string, string[]>): string {
  // Determine if this library has multiple variants (suffixes)
  const hasSuffixes = suffixes.length > 1 || (suffixes.length === 1 && suffixes[0] !== '');
  const defaultSuffix = suffixes[0] || '';

  // Build C# array initializer for suffixes: new[] { "outline", "solid" }
  const suffixArrayLiteral = suffixes.map((s) => `"${s}"`).join(', ');

  // Generate static properties for all icons from all suffixes
  // Track already-generated property names to avoid duplicates
  const iconPropertiesLines: string[] = [];
  const generatedNames = new Set<string>();

  for (const suffix of suffixes) {
    const iconNames = iconsBySuffix.get(suffix) ?? [];

    if (hasSuffixes) {
      // For libraries with suffixes, use GetOrLoad(suffix, name)
      // But also provide a simpler GetOrLoad(name) for default suffix icons
      for (const name of iconNames) {
        if (generatedNames.has(name)) {
          continue; // Skip duplicate icon names
        }
        generatedNames.add(name);

        if (suffix === defaultSuffix) {
          iconPropertiesLines.push(`    public static IconDefinition ${name} => Instance.GetOrLoad("${name}");`);
        } else {
          iconPropertiesLines.push(`    public static IconDefinition ${name} => Instance.GetOrLoad("${suffix}", "${name}");`);
        }
      }
    } else {
      // For simple libraries (no suffixes), just use GetOrLoad(name)
      for (const name of iconNames) {
        if (generatedNames.has(name)) {
          continue; // Skip duplicate icon names
        }
        generatedNames.add(name);
        iconPropertiesLines.push(`    public static IconDefinition ${name} => Instance.GetOrLoad("${name}");`);
      }
    }
  }

  const iconProperties = iconPropertiesLines.join('\n').trimEnd();

  if (!hasSuffixes) {
    // -------------------------------------------------------------------------
    // Simple API: Single variant (no suffix selection needed)
    // Uses IconSet from NgIcons.Core
    // -------------------------------------------------------------------------
    return `${header}
using System.Reflection;

namespace ${namespace};

/// <summary>
/// Lazy-loading icon set. Icons are loaded individually on first access.
/// Memory usage is proportional to the number of icons actually used.
/// Use Instance.Get(), Instance.TryGet(), Instance.PreloadAll() for dynamic access.
/// </summary>
public static class Icons
{
    /// <summary>Icon set instance providing Get, TryGet, PreloadAll, IconNames, and Suffixes.</summary>
    public static readonly Core.IconSet Instance = new(Assembly.GetExecutingAssembly(), "${namespace}");

${iconProperties}
}
`;
  }

  // ---------------------------------------------------------------------------
  // Extended API: Multiple variants (suffix selection available)
  // Uses IconSetWithSuffixes from NgIcons.Core
  // ---------------------------------------------------------------------------
  return `${header}
using System.Reflection;

namespace ${namespace};

/// <summary>
/// Lazy-loading icon set with suffix/variant support.
/// Icons are loaded individually on first access.
/// Memory usage is proportional to the number of icons actually used.
/// Use Instance.Get(), Instance.TryGet(), Instance.PreloadAll() for dynamic access.
/// </summary>
public static class Icons
{
    private static readonly string[] _suffixes = new[] { ${suffixArrayLiteral} };

    /// <summary>Icon set instance providing Get, TryGet, PreloadAll, IconNames, Suffixes, and GetIconNames.</summary>
    public static readonly Core.IconSetWithSuffixes Instance = new(Assembly.GetExecutingAssembly(), "${namespace}", "${defaultSuffix}", _suffixes);

${iconProperties}
}
`;
}

// =============================================================================
// Library Processing
// =============================================================================

/**
 * Processes a single icon library: extracts icons and generates C# code.
 *
 * Steps:
 * 1. Read package.json to discover available exports (variants)
 *    - Some packages have single export: '@ng-icons/feather-icons'
 *    - Others have multiple: '@ng-icons/heroicons/outline', '@ng-icons/heroicons/solid'
 * 2. Load icons from each export path
 * 3. Clean up existing generated files
 * 4. Write individual SVG files and index files for each variant
 * 5. Generate Icons.g.cs with the IconSet class
 *
 * @param library - Library configuration with npm package and C# project names
 * @returns Total number of icons extracted
 */
async function generateLibrary(library: Library): Promise<number> {
  // -------------------------------------------------------------------------
  // Step 1: Discover available exports from package.json
  // -------------------------------------------------------------------------
  const pkgPath = path.join(repoRoot, 'node_modules', ...library.npm.split('/'), 'package.json');
  const pkg = await fs.readJson(pkgPath);

  // Extract export keys, excluding package.json itself
  // Examples: ['.'], ['.', './outline', './solid'], ['./baseline', './twotone']
  let exportKeys = Object.keys(pkg.exports ?? {}).filter((key) => key !== './package.json');
  if (exportKeys.length === 0) {
    exportKeys = ['.']; // Default to root export if none specified
  }

  // -------------------------------------------------------------------------
  // Step 2: Load icons from each export
  // -------------------------------------------------------------------------
  const suffixGroups: SuffixIcons[] = [];
  for (const key of exportKeys) {
    // Convert export key to suffix: './outline' -> 'outline', '.' -> ''
    const suffix = key === '.' ? '' : key.slice(2);
    // Build full import path: '@ng-icons/heroicons' + '/outline' -> '@ng-icons/heroicons/outline'
    const importPath = `${library.npm}${key === '.' ? '' : key.slice(1)}`;

    try {
      const loaded = await loadIcons(importPath);
      if (loaded.length > 0) {
        // Sort icons alphabetically by name for consistent output
        loaded.sort((a, b) => a[0].localeCompare(b[0]));
        suffixGroups.push({ suffix, icons: loaded });
      }
    } catch (error) {
      console.warn(`Skipping ${library.npm}${key === '.' ? '' : key.slice(1)}: ${String(error)}`);
    }
  }

  // Sort suffix groups: default ('') first, then alphabetically
  suffixGroups.sort((a, b) => {
    if (a.suffix === '') return -1;
    if (b.suffix === '') return 1;
    return a.suffix.localeCompare(b.suffix);
  });

  // -------------------------------------------------------------------------
  // Step 3: Prepare output directory
  // -------------------------------------------------------------------------
  const projectDir = path.join(repoRoot, 'src', 'Icons', library.project);
  await fs.ensureDir(projectDir);

  // Ensure the project file exists (minimal SDK-style project)
  const projectFilePath = path.join(projectDir, `${library.project}.csproj`);
  await fs.writeFile(projectFilePath, '<Project Sdk="Microsoft.NET.Sdk" />\n', 'utf8');

  // Remove default Class1.cs if present (from project template)
  const defaultClass = path.join(projectDir, 'Class1.cs');
  if (await fs.pathExists(defaultClass)) {
    await fs.remove(defaultClass);
  }

  // Remove old Icons folder and JSON files before generating new ones
  const iconsDir = path.join(projectDir, 'Icons');
  if (await fs.pathExists(iconsDir)) {
    await fs.remove(iconsDir);
  }
  await fs.ensureDir(iconsDir);

  // Also remove old Icons*.json files (from previous non-lazy approach)
  const existingFiles = await fs.readdir(projectDir);
  for (const file of existingFiles) {
    if (file.startsWith('Icons') && file.endsWith('.json')) {
      await fs.remove(path.join(projectDir, file));
    }
  }

  // -------------------------------------------------------------------------
  // Step 4: Write individual SVG files and index files for each suffix group
  // -------------------------------------------------------------------------
  let totalIcons = 0;
  const suffixes: string[] = [];
  const iconsBySuffix = new Map<string, string[]>();

  for (const group of suffixGroups) {
    const suffixDir = group.suffix === ''
      ? iconsDir
      : path.join(iconsDir, group.suffix);

    await fs.ensureDir(suffixDir);

    // Write individual SVG files
    const iconNames: string[] = [];
    for (const [name, svg] of group.icons) {
      await fs.writeFile(path.join(suffixDir, `${name}.svg`), svg, 'utf8');
      iconNames.push(name);
    }

    // Write index file (just names, no SVG content)
    const indexFileName = group.suffix === ''
      ? 'index.json'
      : `${group.suffix}.index.json`;
    await fs.writeJson(path.join(iconsDir, indexFileName), iconNames);

    totalIcons += group.icons.length;
    suffixes.push(group.suffix);
    iconsBySuffix.set(group.suffix, iconNames);
  }

  // -------------------------------------------------------------------------
  // Step 5: Generate C# IconSet class
  // -------------------------------------------------------------------------
  const content = generateIconSetClass(library.project, suffixes, iconsBySuffix);
  await fs.writeFile(path.join(projectDir, 'Icons.g.cs'), content, 'utf8');

  const suffixInfo = suffixes.length > 1 ? ` (${suffixes.length} variants: ${suffixes.join(', ')})` : '';
  console.log(`Generated ${totalIcons} icons for ${library.project}${suffixInfo}`);
  return totalIcons;
}

// =============================================================================
// Demo App Updates
// =============================================================================

/**
 * Updates the page title in demo app files with the total icon count.
 * This keeps the demo app's displayed count in sync with actual icons.
 */
async function updatePageTitle(totalIcons: number): Promise<void> {
  const indexHtml = path.join(repoRoot, 'samples', 'NgIcons.Demo', 'wwwroot', 'index.html');
  await updatePageTitleInFile(indexHtml, 'title', totalIcons);
  const homeRazor = path.join(repoRoot, 'samples', 'NgIcons.Demo', 'Pages', 'Home.razor');
  await updatePageTitleInFile(homeRazor, 'PageTitle', totalIcons);
}

/**
 * Updates a specific HTML/Razor element containing the icon count.
 * Matches pattern like "<title>12345 " and replaces with new count.
 */
async function updatePageTitleInFile(htmlPath: string, element: string, totalIcons: number) {
  if (await fs.pathExists(htmlPath)) {
    let html = await fs.readFile(htmlPath, 'utf8');
    html = html.replace(new RegExp(`<${element}>\\d+ `), `<${element}>${totalIcons} `);
    await fs.writeFile(htmlPath, html, 'utf8');
    console.log(`Updated HTML title to "${totalIcons} icons for Blazor apps" in ${htmlPath}`);
  }
}

// =============================================================================
// Version Synchronization
// =============================================================================

/**
 * Syncs the NuGet package version with the @ng-icons/core npm version.
 * This ensures Blazor packages stay in sync with the upstream ng-icons releases.
 *
 * @returns The version string from @ng-icons/core
 */
async function updateDirectoryBuildPropsVersion(): Promise<string> {
  // Read version from the core npm package
  const corePkgPath = path.join(repoRoot, 'node_modules', '@ng-icons', 'core', 'package.json');
  const pkg = await fs.readJson(corePkgPath);
  const npmVersion: string = pkg.version ?? '0.0.0';

  // Update the MSBuild props file that sets version for all projects
  const propsPath = path.join(repoRoot, 'src', 'Icons', 'Directory.Build.props');
  if (await fs.pathExists(propsPath)) {
    let xml = await fs.readFile(propsPath, 'utf8');
    xml = xml.replace(/<Version>[^<]*<\/Version>/, `<Version>${npmVersion}</Version>`);
    await fs.writeFile(propsPath, xml, 'utf8');
    console.log(`Updated version to ${npmVersion} in src/Icons/Directory.Build.props`);
  }

  return npmVersion;
}

// =============================================================================
// Main Entry Point
// =============================================================================

/**
 * Main execution flow:
 * 1. Sync version from npm to NuGet packages
 * 2. Process each icon library (extract icons, generate C#)
 * 3. Update demo app with total icon count
 */
async function main(): Promise<void> {
  // Step 1: Version synchronization
  const version = await updateDirectoryBuildPropsVersion();
  console.log(`Using ng-icons version: ${version}`);

  // Step 2: Process all icon libraries
  let totalIcons = 0;
  for (const lib of libraries) {
    const count = await generateLibrary(lib);
    totalIcons += count;
  }
  console.log(`Total icons generated: ${totalIcons}`);

  // Step 3: Update demo app
  await updatePageTitle(totalIcons);
}

// Execute and handle errors
main().catch((error) => {
  console.error('Extraction failed:', error, (error as Error)?.stack);
  process.exitCode = 1;
});
