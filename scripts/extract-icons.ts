import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

interface Library {
  npm: string;
  project: string;
}

const libraries: Library[] = [
  { npm: '@ng-icons/akar-icons', project: 'NgIcons.AkarIcons' },
  { npm: '@ng-icons/bootstrap-icons', project: 'NgIcons.BootstrapIcons' },
  { npm: '@ng-icons/boxicons', project: 'NgIcons.Boxicons' },
  { npm: '@ng-icons/circum-icons', project: 'NgIcons.CircumIcons' },
  { npm: '@ng-icons/core', project: 'NgIcons.Core' },
  { npm: '@ng-icons/cryptocurrency-icons', project: 'NgIcons.CryptocurrencyIcons' },
  { npm: '@ng-icons/css.gg', project: 'NgIcons.CssGg' },
  { npm: '@ng-icons/devicon', project: 'NgIcons.Devicon' },
  { npm: '@ng-icons/dripicons', project: 'NgIcons.Dripicons' },
  { npm: '@ng-icons/feather-icons', project: 'NgIcons.FeatherIcons' },
  { npm: '@ng-icons/flag-icons', project: 'NgIcons.FlagIcons' },
  { npm: '@ng-icons/font-awesome', project: 'NgIcons.FontAwesome' },
  { npm: '@ng-icons/game-icons', project: 'NgIcons.GameIcons' },
  { npm: '@ng-icons/heroicons', project: 'NgIcons.Heroicons' },
  { npm: '@ng-icons/huge-icons', project: 'NgIcons.HugeIcons' },
  { npm: '@ng-icons/iconoir', project: 'NgIcons.Iconoir' },
  { npm: '@ng-icons/iconsax', project: 'NgIcons.Iconsax' },
  { npm: '@ng-icons/ionicons', project: 'NgIcons.Ionicons' },
  { npm: '@ng-icons/jam-icons', project: 'NgIcons.JamIcons' },
  { npm: '@ng-icons/lets-icons', project: 'NgIcons.LetsIcons' },
  { npm: '@ng-icons/lucide', project: 'NgIcons.Lucide' },
  { npm: '@ng-icons/material-file-icons', project: 'NgIcons.MaterialFileIcons' },
  { npm: '@ng-icons/material-icons', project: 'NgIcons.MaterialIcons' },
  { npm: '@ng-icons/material-symbols', project: 'NgIcons.MaterialSymbols' },
  { npm: '@ng-icons/mynaui', project: 'NgIcons.Mynaui' },
  { npm: '@ng-icons/octicons', project: 'NgIcons.Octicons' },
  { npm: '@ng-icons/phosphor-icons', project: 'NgIcons.PhosphorIcons' },
  { npm: '@ng-icons/radix-icons', project: 'NgIcons.RadixIcons' },
  { npm: '@ng-icons/remixicon', project: 'NgIcons.Remixicon' },
  { npm: '@ng-icons/schematics', project: 'NgIcons.Schematics' },
  { npm: '@ng-icons/simple-icons', project: 'NgIcons.SimpleIcons' },
  { npm: '@ng-icons/solar-icons', project: 'NgIcons.SolarIcons' },
  { npm: '@ng-icons/svgl', project: 'NgIcons.Svgl' },
  { npm: '@ng-icons/tabler-icons', project: 'NgIcons.TablerIcons' },
  { npm: '@ng-icons/tdesign-icons', project: 'NgIcons.TdesignIcons' },
  { npm: '@ng-icons/typicons', project: 'NgIcons.Typicons' },
  { npm: '@ng-icons/ux-aspects', project: 'NgIcons.UxAspects' }
];

const header = `// <auto-generated>
// This file was generated by scripts/extract-icons.ts. Do not edit manually.
// </auto-generated>
#nullable enable
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using NgIcons.Core;
`;

const root = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(root, '..');

async function loadIcons(importPath: string): Promise<Array<[string, string]>> {
  const mod = await import(importPath);
  return Object.entries(mod).filter(([, value]) => typeof value === 'string') as Array<[string, string]>;
}

interface SuffixIcons {
  suffix: string; // '' for default, 'baseline', 'outline', etc.
  icons: Array<[string, string]>;
}

function generateIconSetClass(namespace: string, suffixes: string[]): string {
  const hasSuffixes = suffixes.length > 1 || (suffixes.length === 1 && suffixes[0] !== '');
  const defaultSuffix = suffixes[0] || '';

  // Generate suffix array literal
  const suffixArrayLiteral = suffixes.map((s) => `"${s}"`).join(', ');

  if (!hasSuffixes) {
    // Single file, no suffixes - keep simple API
    return `${header}
namespace ${namespace};

public static class IconSet
{
    private static readonly Lazy<IReadOnlyDictionary<string, IconDefinition>> IconsLoader = new(() => Load(""));

    public static IReadOnlyList<string> Suffixes { get; } = Array.Empty<string>();

    public static IReadOnlyDictionary<string, IconDefinition> All => IconsLoader.Value;

    public static IconDefinition Get(string name) => All[name];

    public static bool TryGet(string name, [NotNullWhen(true)] out IconDefinition? icon) => All.TryGetValue(name, out icon);

    public static IReadOnlyDictionary<string, IconDefinition> GetBySuffix(string suffix) => Load(suffix);

    private static IReadOnlyDictionary<string, IconDefinition> Load(string suffix)
    {
        try
        {
            var resourceName = string.IsNullOrEmpty(suffix)
                ? $"{typeof(IconSet).Namespace}.Icons.json"
                : $"{typeof(IconSet).Namespace}.Icons-{suffix}.json";
            using var stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceName)
                ?? throw new InvalidOperationException($"Resource '{resourceName}' was not found.");
            using var reader = new StreamReader(stream);
            var json = reader.ReadToEnd();
            var parsed = JsonSerializer.Deserialize<Dictionary<string, string>>(json) ?? new Dictionary<string, string>();
            var dict = new Dictionary<string, IconDefinition>(StringComparer.OrdinalIgnoreCase);
            foreach (var kvp in parsed)
            {
                dict[kvp.Key] = new IconDefinition(kvp.Key, kvp.Value);
            }
            return new ReadOnlyDictionary<string, IconDefinition>(dict);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"[ng-icons] Failed to load icons for {typeof(IconSet).Namespace}: {ex}");
            return new ReadOnlyDictionary<string, IconDefinition>(new Dictionary<string, IconDefinition>(StringComparer.OrdinalIgnoreCase));
        }
    }
}
`;
  }

  // Multiple suffixes - include suffix selection
  return `${header}
namespace ${namespace};

public static class IconSet
{
    private static readonly Lazy<IReadOnlyDictionary<string, IconDefinition>> IconsLoader = new(() => Load("${defaultSuffix}"));

    public static IReadOnlyList<string> Suffixes { get; } = new[] { ${suffixArrayLiteral} };

    public static IReadOnlyDictionary<string, IconDefinition> All => IconsLoader.Value;

    public static IconDefinition Get(string name) => All[name];

    public static bool TryGet(string name, [NotNullWhen(true)] out IconDefinition? icon) => All.TryGetValue(name, out icon);

    public static IReadOnlyDictionary<string, IconDefinition> GetBySuffix(string suffix) => Load(suffix);

    private static IReadOnlyDictionary<string, IconDefinition> Load(string suffix)
    {
        try
        {
            var resourceName = string.IsNullOrEmpty(suffix)
                ? $"{typeof(IconSet).Namespace}.Icons.json"
                : $"{typeof(IconSet).Namespace}.Icons-{suffix}.json";
            using var stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceName)
                ?? throw new InvalidOperationException($"Resource '{resourceName}' was not found.");
            using var reader = new StreamReader(stream);
            var json = reader.ReadToEnd();
            var parsed = JsonSerializer.Deserialize<Dictionary<string, string>>(json) ?? new Dictionary<string, string>();
            var dict = new Dictionary<string, IconDefinition>(StringComparer.OrdinalIgnoreCase);
            foreach (var kvp in parsed)
            {
                dict[kvp.Key] = new IconDefinition(kvp.Key, kvp.Value);
            }
            return new ReadOnlyDictionary<string, IconDefinition>(dict);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"[ng-icons] Failed to load icons for {typeof(IconSet).Namespace}: {ex}");
            return new ReadOnlyDictionary<string, IconDefinition>(new Dictionary<string, IconDefinition>(StringComparer.OrdinalIgnoreCase));
        }
    }
}
`;
}

async function generateLibrary(library: Library): Promise<number> {
  const pkgPath = path.join(repoRoot, 'node_modules', ...library.npm.split('/'), 'package.json');
  const pkg = await fs.readJson(pkgPath);
  let exportKeys = Object.keys(pkg.exports ?? {}).filter((key) => key !== './package.json');
  if (exportKeys.length === 0) {
    exportKeys = ['.'];
  }

  const suffixGroups: SuffixIcons[] = [];
  for (const key of exportKeys) {
    const suffix = key === '.' ? '' : key.slice(2); // './baseline' -> 'baseline'
    const importPath = `${library.npm}${key === '.' ? '' : key.slice(1)}`;
    try {
      const loaded = await loadIcons(importPath);
      if (loaded.length > 0) {
        loaded.sort((a, b) => a[0].localeCompare(b[0]));
        suffixGroups.push({ suffix, icons: loaded });
      }
    } catch (error) {
      console.warn(`Skipping ${library.npm}${key === '.' ? '' : key.slice(1)}: ${String(error)}`);
    }
  }

  // Sort suffix groups: default ('') first, then alphabetically
  suffixGroups.sort((a, b) => {
    if (a.suffix === '') return -1;
    if (b.suffix === '') return 1;
    return a.suffix.localeCompare(b.suffix);
  });

  const projectDir = path.join(repoRoot, 'src', library.project);
  await fs.ensureDir(projectDir);

  // Remove default Class1.cs if present
  const defaultClass = path.join(projectDir, 'Class1.cs');
  if (await fs.pathExists(defaultClass)) {
    await fs.remove(defaultClass);
  }

  // Remove old Icons.json files before generating new ones
  const existingFiles = await fs.readdir(projectDir);
  for (const file of existingFiles) {
    if (file.startsWith('Icons') && file.endsWith('.json')) {
      await fs.remove(path.join(projectDir, file));
    }
  }

  let totalIcons = 0;
  const suffixes: string[] = [];

  // Write JSON files for each suffix group
  for (const group of suffixGroups) {
    const iconObject = Object.fromEntries(group.icons);
    const fileName = group.suffix === '' ? 'Icons.json' : `Icons-${group.suffix}.json`;
    await fs.writeJson(path.join(projectDir, fileName), iconObject, { spaces: 0 });
    totalIcons += group.icons.length;
    suffixes.push(group.suffix);
  }

  // Generate the C# class
  const content = generateIconSetClass(library.project, suffixes);
  await fs.writeFile(path.join(projectDir, 'Icons.g.cs'), content, 'utf8');

  const suffixInfo = suffixes.length > 1 ? ` (${suffixes.length} variants: ${suffixes.join(', ')})` : '';
  console.log(`Generated ${totalIcons} icons for ${library.project}${suffixInfo}`);
  return totalIcons;
}

async function updatePageTitle(totalIcons: number): Promise<void> {
  const indexHtml = path.join(repoRoot, 'samples', 'NgIcons.Demo', 'wwwroot', 'index.html');
  await updatePageTitleInFile(indexHtml, 'title', totalIcons);
  const homeRazor = path.join(repoRoot, 'samples', 'NgIcons.Demo', 'Pages', 'Home.razor');
  await updatePageTitleInFile(homeRazor, 'PageTitle', totalIcons);
}

async function updatePageTitleInFile(htmlPath: string, element: string, totalIcons: number) {
  if (await fs.pathExists(htmlPath)) {
    let html = await fs.readFile(htmlPath, 'utf8');
    html = html.replace(new RegExp(`<${element}>\\d+ `), `<${element}>${totalIcons} `);
    await fs.writeFile(htmlPath, html, 'utf8');
    console.log(`Updated HTML title to "${totalIcons} icons for Blazor apps" in ${htmlPath}`);
  }
}

async function updateDirectoryBuildPropsVersion(): Promise<string> {
  const corePkgPath = path.join(repoRoot, 'node_modules', '@ng-icons', 'core', 'package.json');
  const pkg = await fs.readJson(corePkgPath);
  const npmVersion: string = pkg.version ?? '0.0.0';

  const propsPath = path.join(repoRoot, 'src', 'Directory.Build.props');
  if (await fs.pathExists(propsPath)) {
    let xml = await fs.readFile(propsPath, 'utf8');
    xml = xml.replace(/<Version>[^<]*<\/Version>/, `<Version>${npmVersion}</Version>`);
    await fs.writeFile(propsPath, xml, 'utf8');
    console.log(`Updated version to ${npmVersion} in src/Directory.Build.props`);
  }

  return npmVersion;
}

async function main(): Promise<void> {
  const version = await updateDirectoryBuildPropsVersion();
  console.log(`Using ng-icons version: ${version}`);

  let totalIcons = 0;
  for (const lib of libraries) {
    const count = await generateLibrary(lib);
    totalIcons += count;
  }
  console.log(`Total icons generated: ${totalIcons}`);
  await updatePageTitle(totalIcons);
}

main().catch((error) => {
  console.error('Extraction failed:', error, (error as Error)?.stack);
  process.exitCode = 1;
});
