import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

interface Library {
  npm: string;
  project: string;
}

const libraries: Library[] = [
  { npm: '@ng-icons/akar-icons', project: 'NgIcons.AkarIcons' },
  { npm: '@ng-icons/bootstrap-icons', project: 'NgIcons.BootstrapIcons' },
  { npm: '@ng-icons/boxicons', project: 'NgIcons.Boxicons' },
  { npm: '@ng-icons/circum-icons', project: 'NgIcons.CircumIcons' },
  { npm: '@ng-icons/core', project: 'NgIcons.Core' },
  { npm: '@ng-icons/cryptocurrency-icons', project: 'NgIcons.CryptocurrencyIcons' },
  { npm: '@ng-icons/css.gg', project: 'NgIcons.CssGg' },
  { npm: '@ng-icons/devicon', project: 'NgIcons.Devicon' },
  { npm: '@ng-icons/dripicons', project: 'NgIcons.Dripicons' },
  { npm: '@ng-icons/feather-icons', project: 'NgIcons.FeatherIcons' },
  { npm: '@ng-icons/flag-icons', project: 'NgIcons.FlagIcons' },
  { npm: '@ng-icons/font-awesome', project: 'NgIcons.FontAwesome' },
  { npm: '@ng-icons/game-icons', project: 'NgIcons.GameIcons' },
  { npm: '@ng-icons/heroicons', project: 'NgIcons.Heroicons' },
  { npm: '@ng-icons/huge-icons', project: 'NgIcons.HugeIcons' },
  { npm: '@ng-icons/iconoir', project: 'NgIcons.Iconoir' },
  { npm: '@ng-icons/iconsax', project: 'NgIcons.Iconsax' },
  { npm: '@ng-icons/ionicons', project: 'NgIcons.Ionicons' },
  { npm: '@ng-icons/jam-icons', project: 'NgIcons.JamIcons' },
  { npm: '@ng-icons/lets-icons', project: 'NgIcons.LetsIcons' },
  { npm: '@ng-icons/lucide', project: 'NgIcons.Lucide' },
  { npm: '@ng-icons/material-file-icons', project: 'NgIcons.MaterialFileIcons' },
  { npm: '@ng-icons/material-icons', project: 'NgIcons.MaterialIcons' },
  { npm: '@ng-icons/material-symbols', project: 'NgIcons.MaterialSymbols' },
  { npm: '@ng-icons/mynaui', project: 'NgIcons.Mynaui' },
  { npm: '@ng-icons/octicons', project: 'NgIcons.Octicons' },
  { npm: '@ng-icons/phosphor-icons', project: 'NgIcons.PhosphorIcons' },
  { npm: '@ng-icons/radix-icons', project: 'NgIcons.RadixIcons' },
  { npm: '@ng-icons/remixicon', project: 'NgIcons.Remixicon' },
  { npm: '@ng-icons/schematics', project: 'NgIcons.Schematics' },
  { npm: '@ng-icons/simple-icons', project: 'NgIcons.SimpleIcons' },
  { npm: '@ng-icons/solar-icons', project: 'NgIcons.SolarIcons' },
  { npm: '@ng-icons/svgl', project: 'NgIcons.Svgl' },
  { npm: '@ng-icons/tabler-icons', project: 'NgIcons.TablerIcons' },
  { npm: '@ng-icons/tdesign-icons', project: 'NgIcons.TdesignIcons' },
  { npm: '@ng-icons/typicons', project: 'NgIcons.Typicons' },
  { npm: '@ng-icons/ux-aspects', project: 'NgIcons.UxAspects' }
];

const header = `// <auto-generated>
// This file was generated by scripts/extract-icons.ts. Do not edit manually.
// </auto-generated>
#nullable enable
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using NgIcons.Core;
`;

const root = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(root, '..');

async function loadIcons(importPath: string): Promise<Array<[string, string]>> {
  const mod = await import(importPath);
  return Object.entries(mod).filter(([, value]) => typeof value === 'string') as Array<[string, string]>;
}

async function generateLibrary(library: Library): Promise<number> {
  const pkgPath = path.join(repoRoot, 'node_modules', ...library.npm.split('/'), 'package.json');
  const pkg = await fs.readJson(pkgPath);
  const npmVersion: string = pkg.version ?? '0.0.0';
  let exportKeys = Object.keys(pkg.exports ?? {}).filter((key) => key !== './package.json');
  if (exportKeys.length === 0) {
    exportKeys = ['.'];
  }

  const icons: Array<[string, string]> = [];
  for (const key of exportKeys) {
    const suffix = key === '.' ? '' : key.slice(1);
    const importPath = `${library.npm}${suffix}`;
    try {
      const loaded = await loadIcons(importPath);
      icons.push(...loaded);
    } catch (error) {
      console.warn(`Skipping ${library.npm}${suffix}: ${String(error)}`);
    }
  }

  icons.sort((a, b) => a[0].localeCompare(b[0]));

  const iconObject = Object.fromEntries(icons);

  const content = `${header}
namespace ${library.project};

public static class IconSet
{
    private static readonly Lazy<IReadOnlyDictionary<string, IconDefinition>> IconsLoader = new(Load);

    public static IReadOnlyDictionary<string, IconDefinition> All => IconsLoader.Value;

    public static bool TryGet(string name, [NotNullWhen(true)] out IconDefinition? icon) => All.TryGetValue(name, out icon);

    private static IReadOnlyDictionary<string, IconDefinition> Load()
    {
        try
        {
            var resourceName = $"{typeof(IconSet).Namespace}.Icons.json";
            using var stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceName)
                ?? throw new InvalidOperationException($"Resource '{resourceName}' was not found.");
            using var reader = new StreamReader(stream);
            var json = reader.ReadToEnd();
            var parsed = JsonSerializer.Deserialize<Dictionary<string, string>>(json) ?? new Dictionary<string, string>();
            var dict = new Dictionary<string, IconDefinition>(StringComparer.OrdinalIgnoreCase);
            foreach (var kvp in parsed)
            {
                dict[kvp.Key] = new IconDefinition(kvp.Key, kvp.Value);
            }
            return new ReadOnlyDictionary<string, IconDefinition>(dict);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"[ng-icons] Failed to load icons for {typeof(IconSet).Namespace}: {ex}");
            return new ReadOnlyDictionary<string, IconDefinition>(new Dictionary<string, IconDefinition>(StringComparer.OrdinalIgnoreCase));
        }
    }
}
`;

  const projectDir = path.join(repoRoot, 'src', library.project);
  await fs.ensureDir(projectDir);
  const defaultClass = path.join(projectDir, 'Class1.cs');
  if (await fs.pathExists(defaultClass)) {
    await fs.remove(defaultClass);
  }
  await fs.writeJson(path.join(projectDir, 'Icons.json'), iconObject, { spaces: 0 });
  await fs.writeFile(path.join(projectDir, 'Icons.g.cs'), content, 'utf8');

  const csprojPath = path.join(projectDir, `${library.project}.csproj`);
  if (await fs.pathExists(csprojPath)) {
    let xml = await fs.readFile(csprojPath, 'utf8');
    if (xml.includes('<Version>')) {
      xml = xml.replace(/<Version>[^<]*<\/Version>/, `<Version>${npmVersion}</Version>`);
    } else {
      xml = xml.replace(/<PropertyGroup>/, `<PropertyGroup>\n    <Version>${npmVersion}</Version>`);
    }
    if (!xml.includes('Icons.json')) {
      xml = xml.replace(
        /<\/Project>/,
        `  <ItemGroup>\n    <EmbeddedResource Include=\"Icons.json\" />\n  </ItemGroup>\n</Project>`
      );
    }
    await fs.writeFile(csprojPath, xml, 'utf8');
  }

  console.log(`Generated ${icons.length} icons for ${library.project}`);
  return icons.length;
}

async function updatePageTitle(totalIcons: number): Promise<void> {
  const indexHtml = path.join(repoRoot, 'samples', 'NgIcons.Demo', 'wwwroot', 'index.html');
  await updatePageTitleInFile(indexHtml, 'title', totalIcons);
  const homeRazor = path.join(repoRoot, 'samples', 'NgIcons.Demo', 'Pages', 'Home.razor');
  await updatePageTitleInFile(homeRazor, 'PageTitle', totalIcons);
}

async function updatePageTitleInFile(htmlPath: string, element: string, totalIcons: number) {
  if (await fs.pathExists(htmlPath)) {
    let html = await fs.readFile(htmlPath, 'utf8');
    html = html.replace(new RegExp(`<${element}>\\d+ `), `<${element}>${totalIcons} `);
    await fs.writeFile(htmlPath, html, 'utf8');
    console.log(`Updated HTML title to "${totalIcons} icons for Blazor apps" in ${htmlPath}`);
  }
}

async function main(): Promise<void> {
  let totalIcons = 0;
  for (const lib of libraries) {
    const count = await generateLibrary(lib);
    totalIcons += count;
  }
  console.log(`Total icons generated: ${totalIcons}`);
  await updatePageTitle(totalIcons);
}

main().catch((error) => {
  console.error('Extraction failed:', error, (error as Error)?.stack);
  process.exitCode = 1;
});
